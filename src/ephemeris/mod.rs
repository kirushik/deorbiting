//! Ephemeris module for computing celestial body positions.
//!
//! Runtime behavior:
//! - Prefer table-based ephemeris generated from JPL Horizons (when present in `assets/ephemeris/`).
//! - Fall back to analytic Keplerian orbits otherwise.
//!
//! Coordinate frame:
//! - 2D heliocentric (Sun at origin), J2000 ecliptic plane.

pub mod data;
pub mod horizons_tables;
pub mod kepler;
pub mod table;

pub use data::{CelestialBodyData, CelestialBodyId, all_bodies};

use crate::types::G;
use bevy::math::DVec2;
use bevy::prelude::*;
use std::collections::HashMap;
use std::sync::RwLock;

/// A constant (Δpos, Δvel) offset applied to a base ephemeris state.
#[derive(Clone, Copy, Debug, Default)]
struct StateOffset2 {
    dp: DVec2,
    dv: DVec2,
}

/// Resource providing ephemeris data for all celestial bodies.
#[derive(Resource)]
pub struct Ephemeris {
    /// Mapping from entity to celestial body ID
    entity_to_id: HashMap<Entity, CelestialBodyId>,
    /// Mapping from celestial body ID to entity
    id_to_entity: HashMap<CelestialBodyId, Entity>,
    /// Cached body data (masses, radii, and legacy Kepler elements)
    body_data: HashMap<CelestialBodyId, CelestialBodyData>,

    /// Optional high-accuracy ephemeris tables generated from JPL Horizons.
    horizons: Option<horizons_tables::HorizonsTables>,

    /// Continuity offsets used when we fall back from Horizons tables to Kepler past table end.
    ///
    /// For each body with a table, if `t > table.end_time()`, we compute the Kepler state at the
    /// table end and apply a (Δpos, Δvel) offset so that Kepler matches the table exactly at the
    /// boundary. This avoids discontinuities when table coverage expires (e.g. after ~200 years
    /// for outer planets and major moons).
    ///
    /// This is cached via a thread-safe lock so `get_position_by_id` / `get_velocity_by_id` can
    /// remain `&self` while still satisfying Bevy `Resource` bounds.
    horizons_fallback_offsets: RwLock<HashMap<CelestialBodyId, StateOffset2>>,
}

impl Default for Ephemeris {
    fn default() -> Self {
        Self::new()
    }
}

impl Ephemeris {
    /// Create a new ephemeris with all celestial body data loaded.
    ///
    /// If `assets/ephemeris/*.bin` is present (generated by the exporter script),
    /// those tables will be used for higher accuracy. Otherwise, we fall back
    /// to the baked-in Keplerian elements.
    pub fn new() -> Self {
        let mut body_data = HashMap::new();
        for data in all_bodies() {
            body_data.insert(data.id, data);
        }

        let horizons = horizons_tables::HorizonsTables::load_from_assets_dir().ok();

        Self {
            entity_to_id: HashMap::new(),
            id_to_entity: HashMap::new(),
            body_data,
            horizons,
            horizons_fallback_offsets: RwLock::new(HashMap::new()),
        }
    }

    /// Register an entity as a celestial body.
    pub fn register(&mut self, entity: Entity, id: CelestialBodyId) {
        self.entity_to_id.insert(entity, id);
        self.id_to_entity.insert(id, entity);
    }

    /// Get the entity for a celestial body ID.
    pub fn get_entity(&self, id: CelestialBodyId) -> Option<Entity> {
        self.id_to_entity.get(&id).copied()
    }

    /// Get the celestial body ID for an entity.
    pub fn get_id(&self, entity: Entity) -> Option<CelestialBodyId> {
        self.entity_to_id.get(&entity).copied()
    }

    /// Get the body data for an entity.
    pub fn get_body_data(&self, entity: Entity) -> Option<&CelestialBodyData> {
        let id = self.entity_to_id.get(&entity)?;
        self.body_data.get(id)
    }

    /// Get the body data for a celestial body ID.
    pub fn get_body_data_by_id(&self, id: CelestialBodyId) -> Option<&CelestialBodyData> {
        self.body_data.get(&id)
    }

    /// Get the mass of a celestial body (kg).
    pub fn get_mass(&self, entity: Entity) -> Option<f64> {
        self.get_body_data(entity).map(|d| d.mass)
    }

    /// Get the physical radius of a celestial body (meters).
    pub fn get_radius(&self, entity: Entity) -> Option<f64> {
        self.get_body_data(entity).map(|d| d.radius)
    }

    /// Compute position of a celestial body at given time.
    ///
    /// # Arguments
    /// * `entity` - The entity representing the celestial body
    /// * `time` - Time in seconds since J2000 epoch
    ///
    /// # Returns
    /// Position in meters from solar system barycenter, or None if entity not found.
    pub fn get_position(&self, entity: Entity, time: f64) -> Option<DVec2> {
        let id = self.entity_to_id.get(&entity)?;
        self.get_position_by_id(*id, time)
    }

    /// Compute position of a celestial body by ID at given time.
    pub fn get_position_by_id(&self, id: CelestialBodyId, time: f64) -> Option<DVec2> {
        // Prefer high-accuracy Horizons table ephemeris when available.
        //
        // If `time` is outside the table range, we fall back to Kepler but apply a per-body
        // offset so the transition is continuous at the boundary.
        if let Some(h) = &self.horizons {
            if let Some(tbl) = h.table(id) {
                let start = tbl.start_time();
                let end = tbl.end_time();

                if time >= start && time <= end {
                    if let Ok(state) = tbl.sample(time) {
                        return Some(state.pos);
                    }
                    // If sampling failed for some unexpected reason, fall through to Kepler.
                } else if time > end {
                    // Past coverage end: patched Kepler continuation (C0/C1 at end).
                    let base = self.get_kepler_position_by_id(id, time)?;

                    // Compute or reuse the (Δpos, Δvel) offset at the end boundary.
                    let offset = self.get_or_compute_horizons_offset(id, end)?;
                    return Some(base + offset.dp);
                }
                // For `time < start`, we intentionally fall back to Kepler without offsets.
                // Tables are forward-only by design; negative times are not guaranteed.
            }
        }

        // No table available: pure Kepler model.
        self.get_kepler_position_by_id(id, time)
    }

    /// Compute velocity of a celestial body at given time.
    ///
    /// # Arguments
    /// * `entity` - The entity representing the celestial body
    /// * `time` - Time in seconds since J2000 epoch
    ///
    /// # Returns
    /// Velocity in m/s, or None if entity not found.
    pub fn get_velocity(&self, entity: Entity, time: f64) -> Option<DVec2> {
        let id = self.entity_to_id.get(&entity)?;
        self.get_velocity_by_id(*id, time)
    }

    /// Compute velocity of a celestial body by ID at given time.
    pub fn get_velocity_by_id(&self, id: CelestialBodyId, time: f64) -> Option<DVec2> {
        // Prefer high-accuracy Horizons table ephemeris when available.
        //
        // If `time` is outside the table range, we fall back to Kepler but apply a per-body
        // offset so the transition is continuous at the boundary.
        if let Some(h) = &self.horizons {
            if let Some(tbl) = h.table(id) {
                let start = tbl.start_time();
                let end = tbl.end_time();

                if time >= start && time <= end {
                    if let Ok(state) = tbl.sample(time) {
                        return Some(state.vel);
                    }
                    // If sampling failed for some unexpected reason, fall through to Kepler.
                } else if time > end {
                    // Past coverage end: patched Kepler continuation (C0/C1 at end).
                    let base = self.get_kepler_velocity_by_id(id, time)?;

                    // Compute or reuse the (Δpos, Δvel) offset at the end boundary.
                    let offset = self.get_or_compute_horizons_offset(id, end)?;
                    return Some(base + offset.dv);
                }
                // For `time < start`, we intentionally fall back to Kepler without offsets.
                // Tables are forward-only by design; negative times are not guaranteed.
            }
        }

        // No table available: pure Kepler model.
        self.get_kepler_velocity_by_id(id, time)
    }

    /// Get all gravity sources at a given time.
    ///
    /// Returns positions and GM (μ = G·M) values, NOT masses.
    /// GM is the standard gravitational parameter in m³/s².
    /// Use directly in acceleration formula: a = GM/r² (no need to multiply by G).
    ///
    /// # Arguments
    /// * `time` - Time in seconds since J2000 epoch
    ///
    /// # Returns
    /// Vector of (position in meters, GM in m³/s²) pairs for all massive bodies.
    pub fn get_gravity_sources(&self, time: f64) -> Vec<(DVec2, f64)> {
        let mut sources = Vec::new();

        // Sun
        if let Some(sun_data) = self.body_data.get(&CelestialBodyId::Sun) {
            sources.push((DVec2::ZERO, G * sun_data.mass));
        }

        // Planets
        for &id in CelestialBodyId::PLANETS {
            if let (Some(pos), Some(data)) =
                (self.get_position_by_id(id, time), self.body_data.get(&id))
            {
                sources.push((pos, G * data.mass));
            }
        }

        // Moons (significant for close encounters)
        for &id in CelestialBodyId::MOONS {
            if let (Some(pos), Some(data)) =
                (self.get_position_by_id(id, time), self.body_data.get(&id))
            {
                sources.push((pos, G * data.mass));
            }
        }

        sources
    }

    /// Check if a position collides with any celestial body.
    ///
    /// # Arguments
    /// * `pos` - Position to check (meters from barycenter)
    /// * `time` - Time in seconds since J2000 epoch
    ///
    /// # Returns
    /// Some(CelestialBodyId) if collision detected, None otherwise.
    pub fn check_collision(&self, pos: DVec2, time: f64) -> Option<CelestialBodyId> {
        // Check Sun
        if let Some(sun_data) = self.body_data.get(&CelestialBodyId::Sun) {
            if pos.length() < sun_data.radius {
                return Some(CelestialBodyId::Sun);
            }
        }

        // Check planets
        for &id in CelestialBodyId::PLANETS {
            if let (Some(body_pos), Some(data)) =
                (self.get_position_by_id(id, time), self.body_data.get(&id))
            {
                if (pos - body_pos).length() < data.radius {
                    return Some(id);
                }
            }
        }

        // Check moons
        for &id in CelestialBodyId::MOONS {
            if let (Some(body_pos), Some(data)) =
                (self.get_position_by_id(id, time), self.body_data.get(&id))
            {
                if (pos - body_pos).length() < data.radius {
                    return Some(id);
                }
            }
        }

        None
    }

    /// Get all registered entity-ID pairs.
    pub fn all_registered(&self) -> impl Iterator<Item = (Entity, CelestialBodyId)> + '_ {
        self.entity_to_id.iter().map(|(&e, &id)| (e, id))
    }

    fn get_kepler_position_by_id(&self, id: CelestialBodyId, time: f64) -> Option<DVec2> {
        let data = self.body_data.get(&id)?;

        match &data.orbit {
            None => Some(DVec2::ZERO), // Sun at origin
            Some(orbit) => {
                let local_pos = orbit.get_local_position(time);

                // Legacy hierarchical orbits (moons): parent heliocentric + local orbit
                match id.parent() {
                    None => Some(local_pos), // Heliocentric orbit
                    Some(parent_id) => {
                        let parent_pos = self.get_position_by_id(parent_id, time)?;
                        Some(parent_pos + local_pos)
                    }
                }
            }
        }
    }

    fn get_kepler_velocity_by_id(&self, id: CelestialBodyId, time: f64) -> Option<DVec2> {
        let data = self.body_data.get(&id)?;

        match &data.orbit {
            None => Some(DVec2::ZERO), // Sun stationary
            Some(orbit) => {
                let local_vel = orbit.get_local_velocity(time);

                // Legacy hierarchical orbits (moons): parent heliocentric + local orbit
                match id.parent() {
                    None => Some(local_vel), // Heliocentric
                    Some(parent_id) => {
                        let parent_vel = self.get_velocity_by_id(parent_id, time)?;
                        Some(parent_vel + local_vel)
                    }
                }
            }
        }
    }

    /// Computes (or reuses) the table→Kepler continuity offset at `t_end`.
    fn get_or_compute_horizons_offset(
        &self,
        id: CelestialBodyId,
        t_end: f64,
    ) -> Option<StateOffset2> {
        // First, try the cache.
        if let Ok(guard) = self.horizons_fallback_offsets.read() {
            if let Some(offset) = guard.get(&id).copied() {
                return Some(offset);
            }
        }

        let h = self.horizons.as_ref()?;
        let tbl = h.table(id)?;

        let table_end = tbl.sample(t_end).ok()?;
        let kepler_end_pos = self.get_kepler_position_by_id(id, t_end)?;
        let kepler_end_vel = self.get_kepler_velocity_by_id(id, t_end)?;

        let offset = StateOffset2 {
            dp: table_end.pos - kepler_end_pos,
            dv: table_end.vel - kepler_end_vel,
        };

        // Cache it (best-effort; if lock is poisoned, just skip caching).
        if let Ok(mut guard) = self.horizons_fallback_offsets.write() {
            guard.insert(id, offset);
        }

        Some(offset)
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::types::{AU_TO_METERS, SECONDS_PER_DAY};

    #[test]
    fn test_ephemeris_creation() {
        let eph = Ephemeris::new();
        assert!(eph.body_data.contains_key(&CelestialBodyId::Sun));
        assert!(eph.body_data.contains_key(&CelestialBodyId::Earth));
        assert!(eph.body_data.contains_key(&CelestialBodyId::Moon));
    }

    #[test]
    fn test_sun_position() {
        let eph = Ephemeris::new();
        let sun_pos = eph.get_position_by_id(CelestialBodyId::Sun, 0.0);
        assert_eq!(sun_pos, Some(DVec2::ZERO));
    }

    #[test]
    fn test_earth_position_at_epoch() {
        let eph = Ephemeris::new();
        let earth_pos = eph.get_position_by_id(CelestialBodyId::Earth, 0.0).unwrap();

        // Earth should be roughly 1 AU from Sun at J2000
        let distance_au = earth_pos.length() / AU_TO_METERS;
        assert!(
            (distance_au - 1.0).abs() < 0.02,
            "Earth should be ~1 AU from Sun, got {} AU",
            distance_au
        );
    }

    #[test]
    fn test_moon_position_relative_to_earth() {
        let eph = Ephemeris::new();

        let earth_pos = eph.get_position_by_id(CelestialBodyId::Earth, 0.0).unwrap();
        let moon_pos = eph.get_position_by_id(CelestialBodyId::Moon, 0.0).unwrap();

        // Moon should be ~384,400 km from Earth
        let distance_km = (moon_pos - earth_pos).length() / 1000.0;
        assert!(
            (distance_km - 384400.0).abs() < 50000.0,
            "Moon should be ~384,400 km from Earth, got {} km",
            distance_km
        );
    }

    #[test]
    fn test_gravity_sources() {
        let eph = Ephemeris::new();
        let sources = eph.get_gravity_sources(0.0);

        // Should have Sun + 8 planets + 6 moons = 15 sources
        assert_eq!(sources.len(), 15);

        // Sun should have largest GM
        let sun_gm = sources[0].1;
        for (_, gm) in &sources[1..] {
            assert!(sun_gm > *gm);
        }
    }

    #[test]
    fn test_collision_detection() {
        let eph = Ephemeris::new();

        // Position at Sun's center should collide
        let collision = eph.check_collision(DVec2::ZERO, 0.0);
        assert_eq!(collision, Some(CelestialBodyId::Sun));

        // Position far from everything should not collide
        let far_pos = DVec2::new(100.0 * AU_TO_METERS, 0.0);
        let no_collision = eph.check_collision(far_pos, 0.0);
        assert!(no_collision.is_none());
    }

    #[test]
    fn test_entity_registration() {
        let mut eph = Ephemeris::new();

        // Create fake entities (in real usage these come from Bevy)
        let fake_entity = Entity::from_raw(42);

        eph.register(fake_entity, CelestialBodyId::Earth);

        assert_eq!(eph.get_id(fake_entity), Some(CelestialBodyId::Earth));
        assert_eq!(eph.get_entity(CelestialBodyId::Earth), Some(fake_entity));
    }

    #[test]
    fn test_planetary_motion_over_time() {
        let eph = Ephemeris::new();

        // Earth position at J2000
        let earth_pos_0 = eph.get_position_by_id(CelestialBodyId::Earth, 0.0).unwrap();

        // Earth position after ~6 months (half orbit)
        let half_year_seconds = 182.625 * SECONDS_PER_DAY;
        let earth_pos_half = eph
            .get_position_by_id(CelestialBodyId::Earth, half_year_seconds)
            .unwrap();

        // Positions should be roughly opposite
        let dot = earth_pos_0.normalize().dot(earth_pos_half.normalize());
        assert!(
            dot < -0.8,
            "Earth after 6 months should be on opposite side of orbit, dot product = {}",
            dot
        );
    }

    #[test]
    fn test_continuity_offsets_do_not_introduce_jumps_when_tables_expire() {
        let eph = Ephemeris::new();

        // If no Horizons tables are loaded (common in CI), this test is a no-op.
        let Some(h) = eph.horizons.as_ref() else {
            return;
        };

        // Pick a representative body that likely has a table if tables are present.
        // (Earth is included in all documented export sets.)
        let id = CelestialBodyId::Earth;
        let Some(cov) = h.coverage(id) else {
            return;
        };

        // Test just beyond the end boundary. We sample both sides of the boundary using a small dt.
        // dt is chosen small enough to approximate continuity while being > 0.
        let dt = 1.0; // 1 second
        let t0 = cov.end;
        let t1 = cov.end + dt;

        let p0 = eph.get_position_by_id(id, t0).unwrap();
        let p1 = eph.get_position_by_id(id, t1).unwrap();
        let v0 = eph.get_velocity_by_id(id, t0).unwrap();
        let v1 = eph.get_velocity_by_id(id, t1).unwrap();

        // Expect that the position advances roughly according to v0 * dt (first-order),
        // and that v is continuous (no huge instantaneous delta).
        let predicted = p0 + v0 * dt;
        let pos_err = (p1 - predicted).length();
        let vel_jump = (v1 - v0).length();

        // These are intentionally loose game-physics tolerances:
        // - position error on the order of km over 1 second would be absurd
        // - velocity jump on the order of km/s would be a visible discontinuity
        assert!(
            pos_err < 1.0e6,
            "Position should remain continuous across table expiry (pos_err = {} m)",
            pos_err
        );
        assert!(
            vel_jump < 1.0e3,
            "Velocity should remain continuous across table expiry (vel_jump = {} m/s)",
            vel_jump
        );
    }

    #[test]
    fn test_continuity_offsets_work_for_moons_if_tables_present() {
        let eph = Ephemeris::new();

        // If no Horizons tables are loaded, this test is a no-op.
        let Some(h) = eph.horizons.as_ref() else {
            return;
        };

        // Moon is a good coverage-stress case (short cadence, often different coverage limits).
        let id = CelestialBodyId::Moon;
        let Some(cov) = h.coverage(id) else {
            return;
        };

        let dt = 1.0; // 1 second
        let t0 = cov.end;
        let t1 = cov.end + dt;

        let p0 = eph.get_position_by_id(id, t0).unwrap();
        let p1 = eph.get_position_by_id(id, t1).unwrap();
        let v0 = eph.get_velocity_by_id(id, t0).unwrap();
        let v1 = eph.get_velocity_by_id(id, t1).unwrap();

        let predicted = p0 + v0 * dt;
        let pos_err = (p1 - predicted).length();
        let vel_jump = (v1 - v0).length();

        assert!(
            pos_err < 1.0e6,
            "Moon position should remain continuous across table expiry (pos_err = {} m)",
            pos_err
        );
        assert!(
            vel_jump < 1.0e3,
            "Moon velocity should remain continuous across table expiry (vel_jump = {} m/s)",
            vel_jump
        );
    }
}
