//! Ephemeris module for computing celestial body positions.
//!
//! Runtime behavior:
//! - Prefer table-based ephemeris generated from JPL Horizons (when present in `assets/ephemeris/`).
//! - Fall back to analytic Keplerian orbits otherwise.
//!
//! Coordinate frame:
//! - 2D heliocentric (Sun at origin), J2000 ecliptic plane.

pub mod data;
#[cfg(feature = "embedded-ephemeris")]
mod embedded_tables;
pub mod horizons_tables;
pub mod kepler;
pub mod table;

#[cfg(test)]
mod proptest_ephemeris;

pub use data::{CelestialBodyData, CelestialBodyId, CelestialBodyTrivia, all_bodies, get_trivia};
pub use horizons_tables::TableCoverage;
use table::State2;

use crate::types::G;
use bevy::math::DVec2;
use bevy::prelude::*;
use std::collections::HashMap;

/// Multiplier for planet collision detection radius.
///
/// For gameplay purposes, we detect collision when an asteroid enters
/// the "danger zone" around a celestial body, not just its physical surface.
/// This makes the game playable while representing realistic intervention thresholds.
///
/// At 50x, Earth's danger zone is ~320,000 km (about the Moon's orbital distance).
///
/// Note: The Sun uses a separate 2x multiplier (see `SUN_COLLISION_MULT` in
/// `get_gravity_sources_full`). This is because the Sun is already huge
/// (696,000 km radius), and a 2x multiplier creates a ~1.4M km danger zone
/// which is reasonable without making it dominate the inner solar system.
pub const COLLISION_MULTIPLIER: f64 = 50.0;

/// Total number of gravity sources in the solar system model.
/// 1 Sun + 8 Planets = 9 bodies (moons are decorative only)
pub const GRAVITY_SOURCE_COUNT: usize = 9;

/// A gravity source: position and GM (standard gravitational parameter).
/// GM = G * mass, in m³/s². Use directly: a = GM/r²
pub type GravitySource = (DVec2, f64);

/// A gravity source with its ID: (body_id, position, GM).
pub type GravitySourceWithId = (CelestialBodyId, DVec2, f64);

/// Fixed-size array of gravity sources (no heap allocation).
pub type GravitySources = [GravitySource; GRAVITY_SOURCE_COUNT];

/// Fixed-size array of gravity sources with IDs (no heap allocation).
pub type GravitySourcesWithId = [GravitySourceWithId; GRAVITY_SOURCE_COUNT];

/// A full gravity source with all data needed for physics calculations.
/// Includes ID, position, GM, and collision radius - everything needed
/// for gravity, dominant body detection, and collision checking in one lookup.
#[derive(Clone, Copy, Debug)]
pub struct GravitySourceFull {
    pub id: CelestialBodyId,
    pub pos: DVec2,
    pub gm: f64,
    pub collision_radius: f64,
}

/// Fixed-size array of full gravity sources (no heap allocation).
pub type GravitySourcesFull = [GravitySourceFull; GRAVITY_SOURCE_COUNT];

/// Pre-computed GM values for all bodies in standard order.
/// Order: Sun, Mercury, Venus, Earth, Mars, Jupiter, Saturn, Uranus, Neptune,
///        Moon, Io, Europa, Ganymede, Callisto, Titan.
type GmCache = [f64; GRAVITY_SOURCE_COUNT];

/// Resource providing ephemeris data for all celestial bodies.
#[derive(Resource)]
pub struct Ephemeris {
    /// Mapping from entity to celestial body ID
    entity_to_id: HashMap<Entity, CelestialBodyId>,
    /// Mapping from celestial body ID to entity
    id_to_entity: HashMap<CelestialBodyId, Entity>,
    /// Cached body data (masses, radii, and legacy Kepler elements)
    body_data: HashMap<CelestialBodyId, CelestialBodyData>,

    /// Optional high-accuracy ephemeris tables generated from JPL Horizons.
    horizons: Option<horizons_tables::HorizonsTables>,

    /// Pre-computed GM values for all bodies (computed once at startup).
    gm_cache: GmCache,

    /// Pre-computed collision radii for all bodies (computed once at startup).
    collision_cache: [f64; GRAVITY_SOURCE_COUNT],
}

impl Default for Ephemeris {
    fn default() -> Self {
        Self::new()
    }
}

/// Standard body order for gravity sources array.
/// Only includes Sun + 8 planets (moons are decorative only).
const BODY_ORDER: [CelestialBodyId; GRAVITY_SOURCE_COUNT] = [
    CelestialBodyId::Sun,
    CelestialBodyId::Mercury,
    CelestialBodyId::Venus,
    CelestialBodyId::Earth,
    CelestialBodyId::Mars,
    CelestialBodyId::Jupiter,
    CelestialBodyId::Saturn,
    CelestialBodyId::Uranus,
    CelestialBodyId::Neptune,
];

impl Ephemeris {
    /// Create a new ephemeris with all celestial body data loaded.
    ///
    /// If `assets/ephemeris/*.bin` is present (generated by the exporter script),
    /// those tables will be used for higher accuracy. Otherwise, we fall back
    /// to the baked-in Keplerian elements.
    pub fn new() -> Self {
        const SUN_COLLISION_MULT: f64 = 2.0;

        let mut body_data = HashMap::new();
        for data in all_bodies() {
            body_data.insert(data.id, data);
        }

        let horizons = horizons_tables::HorizonsTables::load_from_assets_dir().ok();

        // Pre-compute GM values for all bodies (computed once, used forever)
        let mut gm_cache = [0.0; GRAVITY_SOURCE_COUNT];
        for (i, &id) in BODY_ORDER.iter().enumerate() {
            if let Some(data) = body_data.get(&id) {
                gm_cache[i] = G * data.mass;
            }
        }

        // Pre-compute collision radii for all bodies
        let mut collision_cache = [0.0; GRAVITY_SOURCE_COUNT];
        for (i, &id) in BODY_ORDER.iter().enumerate() {
            if let Some(data) = body_data.get(&id) {
                let mult = if i == 0 { SUN_COLLISION_MULT } else { COLLISION_MULTIPLIER };
                collision_cache[i] = data.radius * mult;
            }
        }

        Self {
            entity_to_id: HashMap::new(),
            id_to_entity: HashMap::new(),
            body_data,
            horizons,
            gm_cache,
            collision_cache,
        }
    }

    /// Register an entity as a celestial body.
    pub fn register(&mut self, entity: Entity, id: CelestialBodyId) {
        self.entity_to_id.insert(entity, id);
        self.id_to_entity.insert(id, entity);
    }

    /// Get the entity for a celestial body ID.
    pub fn get_entity(&self, id: CelestialBodyId) -> Option<Entity> {
        self.id_to_entity.get(&id).copied()
    }

    /// Get the celestial body ID for an entity.
    pub fn get_id(&self, entity: Entity) -> Option<CelestialBodyId> {
        self.entity_to_id.get(&entity).copied()
    }

    /// Get the body data for an entity.
    pub fn get_body_data(&self, entity: Entity) -> Option<&CelestialBodyData> {
        let id = self.entity_to_id.get(&entity)?;
        self.body_data.get(id)
    }

    /// Get the body data for a celestial body ID.
    pub fn get_body_data_by_id(&self, id: CelestialBodyId) -> Option<&CelestialBodyData> {
        self.body_data.get(&id)
    }

    /// Get the mass of a celestial body (kg).
    pub fn get_mass(&self, entity: Entity) -> Option<f64> {
        self.get_body_data(entity).map(|d| d.mass)
    }

    /// Get the physical radius of a celestial body (meters).
    pub fn get_radius(&self, entity: Entity) -> Option<f64> {
        self.get_body_data(entity).map(|d| d.radius)
    }


    /// Sample state from table if available and in-range.
    /// Returns None if no table, out of range, or sampling fails.
    #[inline]
    fn sample_table_state(&self, id: CelestialBodyId, time: f64) -> Option<State2> {
        let h = self.horizons.as_ref()?;
        let tbl = h.table(id)?;
        if time >= tbl.start_time() && time <= tbl.end_time() {
            tbl.sample(time).ok()
        } else {
            None
        }
    }

    /// Compute position of a celestial body at given time.
    ///
    /// # Arguments
    /// * `entity` - The entity representing the celestial body
    /// * `time` - Time in seconds since J2000 epoch
    ///
    /// # Returns
    /// Position in meters from solar system barycenter, or None if entity not found.
    pub fn get_position(&self, entity: Entity, time: f64) -> Option<DVec2> {
        let id = self.entity_to_id.get(&entity)?;
        self.get_position_by_id(*id, time)
    }

    /// Compute position of a celestial body by ID at given time.
    pub fn get_position_by_id(&self, id: CelestialBodyId, time: f64) -> Option<DVec2> {
        self.sample_table_state(id, time)
            .map(|s| s.pos)
            .or_else(|| self.get_kepler_position_by_id(id, time))
    }

    /// Compute velocity of a celestial body at given time.
    ///
    /// # Arguments
    /// * `entity` - The entity representing the celestial body
    /// * `time` - Time in seconds since J2000 epoch
    ///
    /// # Returns
    /// Velocity in m/s, or None if entity not found.
    pub fn get_velocity(&self, entity: Entity, time: f64) -> Option<DVec2> {
        let id = self.entity_to_id.get(&entity)?;
        self.get_velocity_by_id(*id, time)
    }

    /// Compute velocity of a celestial body by ID at given time.
    pub fn get_velocity_by_id(&self, id: CelestialBodyId, time: f64) -> Option<DVec2> {
        self.sample_table_state(id, time)
            .map(|s| s.vel)
            .or_else(|| self.get_kepler_velocity_by_id(id, time))
    }

    /// Sample positions for all gravity source bodies at given time.
    ///
    /// Returns array of `Option<DVec2>` for each gravity body (Sun + 8 planets).
    /// Sun (index 0) is always at origin. Planets use batched table sampling
    /// when available, with Kepler fallback for missing/out-of-range data.
    ///
    /// This is the single source of truth for position sampling logic used by
    /// `get_gravity_sources()` and `get_gravity_sources_full()`.
    fn sample_gravity_body_positions(&self, time: f64) -> [Option<DVec2>; GRAVITY_SOURCE_COUNT] {
        let mut positions: [Option<DVec2>; GRAVITY_SOURCE_COUNT] =
            [None; GRAVITY_SOURCE_COUNT];

        // Sun is always at origin (index 0)
        positions[0] = Some(DVec2::ZERO);

        // Try batched table sampling for bodies 1-8 (planets only)
        if let Some(h) = &self.horizons {
            let table_positions = h.sample_all_positions(time);
            for (i, table_pos) in table_positions.iter().enumerate() {
                let body_idx = i + 1; // Skip Sun
                positions[body_idx] = table_pos.or_else(|| {
                    // Fallback to individual query (outside table range or missing table)
                    self.get_position_by_id(BODY_ORDER[body_idx], time)
                });
            }
        } else {
            // No tables: use Kepler for all bodies
            for i in 1..GRAVITY_SOURCE_COUNT {
                positions[i] = self.get_position_by_id(BODY_ORDER[i], time);
            }
        }

        positions
    }

    /// Get all gravity sources at a given time.
    ///
    /// Returns positions and GM (μ = G·M) values, NOT masses.
    /// GM is the standard gravitational parameter in m³/s².
    /// Use directly in acceleration formula: a = GM/r² (no need to multiply by G).
    ///
    /// This function returns a fixed-size array to avoid heap allocations.
    /// Uses pre-computed GM cache and batched position queries for performance.
    ///
    /// If a body's position lookup fails, it is logged and the body's GM is set to 0
    /// (effectively excluding it from gravity calculations).
    ///
    /// # Arguments
    /// * `time` - Time in seconds since J2000 epoch
    ///
    /// # Returns
    /// Fixed array of (position in meters, GM in m³/s²) pairs for all massive bodies.
    pub fn get_gravity_sources(&self, time: f64) -> GravitySources {
        let positions = self.sample_gravity_body_positions(time);
        let mut result: GravitySources = [(DVec2::ZERO, 0.0); GRAVITY_SOURCE_COUNT];

        for i in 0..GRAVITY_SOURCE_COUNT {
            if let Some(pos) = positions[i] {
                result[i] = (pos, self.gm_cache[i]);
            } else {
                // Position lookup failed - exclude from gravity (GM = 0)
                warn_once!(
                    "Failed to get position for {:?} at time {:.1}, excluding from gravity",
                    BODY_ORDER[i],
                    time
                );
                result[i] = (DVec2::ZERO, 0.0);
            }
        }

        result
    }

    /// Get all gravity sources with their IDs at a given time.
    ///
    /// Similar to `get_gravity_sources`, but includes the body ID for each source.
    /// Useful for determining which body's gravity dominates at a position.
    ///
    /// This function returns a fixed-size array to avoid heap allocations.
    ///
    /// # Arguments
    /// * `time` - Time in seconds since J2000 epoch
    ///
    /// # Returns
    /// Fixed array of (body_id, position in meters, GM in m³/s²) tuples.
    pub fn get_gravity_sources_with_id(&self, time: f64) -> GravitySourcesWithId {
        // Build the fixed array with IDs (Sun + 8 planets, moons are decorative only)
        [
            // 0: Sun (always at origin)
            self.gravity_source_with_id_for(CelestialBodyId::Sun, time),
            // 1-8: Planets
            self.gravity_source_with_id_for(CelestialBodyId::Mercury, time),
            self.gravity_source_with_id_for(CelestialBodyId::Venus, time),
            self.gravity_source_with_id_for(CelestialBodyId::Earth, time),
            self.gravity_source_with_id_for(CelestialBodyId::Mars, time),
            self.gravity_source_with_id_for(CelestialBodyId::Jupiter, time),
            self.gravity_source_with_id_for(CelestialBodyId::Saturn, time),
            self.gravity_source_with_id_for(CelestialBodyId::Uranus, time),
            self.gravity_source_with_id_for(CelestialBodyId::Neptune, time),
        ]
    }

    /// Helper to get a single gravity source with ID for a body.
    /// Returns GM=0 if position lookup fails.
    #[inline]
    fn gravity_source_with_id_for(&self, id: CelestialBodyId, time: f64) -> GravitySourceWithId {
        if id == CelestialBodyId::Sun {
            let gm = self.body_data.get(&id).map(|d| G * d.mass).unwrap_or(0.0);
            return (id, DVec2::ZERO, gm);
        }

        if let Some(pos) = self.get_position_by_id(id, time) {
            let gm = self.body_data.get(&id).map(|d| G * d.mass).unwrap_or(0.0);
            (id, pos, gm)
        } else {
            // Position lookup failed - exclude from gravity
            (id, DVec2::ZERO, 0.0)
        }
    }

    /// Get all gravity sources with full data in a SINGLE ephemeris pass.
    ///
    /// This method returns position, GM, body ID, AND collision radius for all
    /// gravity sources in one lookup. This is significantly more efficient than
    /// calling `get_gravity_sources()`, `get_gravity_sources_with_id()`, and
    /// performing collision checks separately (which would require 3x the
    /// ephemeris interpolations).
    ///
    /// Use this in trajectory prediction loops where you need all three pieces
    /// of information per timestep.
    ///
    /// If a body's position lookup fails, it is logged and the body's GM is set to 0
    /// (effectively excluding it from gravity calculations).
    ///
    /// # Arguments
    /// * `time` - Time in seconds since J2000 epoch
    ///
    /// # Returns
    /// Fixed array of `GravitySourceFull` with id, position, GM, and collision radius.
    pub fn get_gravity_sources_full(&self, time: f64) -> GravitySourcesFull {
        let positions = self.sample_gravity_body_positions(time);
        let mut result: GravitySourcesFull = [GravitySourceFull {
            id: CelestialBodyId::Sun,
            pos: DVec2::ZERO,
            gm: 0.0,
            collision_radius: 0.0,
        }; GRAVITY_SOURCE_COUNT];

        for i in 0..GRAVITY_SOURCE_COUNT {
            let id = BODY_ORDER[i];

            if let Some(pos) = positions[i] {
                result[i] = GravitySourceFull {
                    id,
                    pos,
                    gm: self.gm_cache[i],
                    collision_radius: self.collision_cache[i],
                };
            } else {
                // Position lookup failed - exclude from gravity (GM = 0)
                warn_once!(
                    "Failed to get position for {:?} at time {:.1}, excluding from gravity",
                    id,
                    time
                );
                result[i] = GravitySourceFull {
                    id,
                    pos: DVec2::ZERO,
                    gm: 0.0,               // Exclude from gravity
                    collision_radius: 0.0, // No collision with missing body
                };
            }
        }

        result
    }

    /// Check if a position collides with any celestial body.
    ///
    /// Uses `COLLISION_MULTIPLIER` to create a "danger zone" around each body.
    /// This makes collision detection more forgiving for gameplay while representing
    /// realistic planetary defense intervention thresholds.
    ///
    /// # Arguments
    /// * `pos` - Position to check (meters from barycenter)
    /// * `time` - Time in seconds since J2000 epoch
    ///
    /// # Returns
    /// Some(CelestialBodyId) if collision detected, None otherwise.
    pub fn check_collision(&self, pos: DVec2, time: f64) -> Option<CelestialBodyId> {
        // Check Sun (use smaller multiplier - Sun is already huge)
        if let Some(sun_data) = self.body_data.get(&CelestialBodyId::Sun)
            && pos.length() < sun_data.radius * 2.0
        {
            return Some(CelestialBodyId::Sun);
        }

        // Check planets - use full COLLISION_MULTIPLIER for danger zone
        // (Moons are decorative only - no collision detection)
        for &id in CelestialBodyId::PLANETS {
            if let (Some(body_pos), Some(data)) =
                (self.get_position_by_id(id, time), self.body_data.get(&id))
                && (pos - body_pos).length() < data.radius * COLLISION_MULTIPLIER
            {
                return Some(id);
            }
        }

        None
    }

    /// Get all registered entity-ID pairs.
    pub fn all_registered(&self) -> impl Iterator<Item = (Entity, CelestialBodyId)> + '_ {
        self.entity_to_id.iter().map(|(&e, &id)| (e, id))
    }

    /// Get the Horizons table coverage for a celestial body.
    ///
    /// Returns the time range covered by the ephemeris table, if one exists.
    /// Returns None if no table is loaded or if the body has no table.
    pub fn horizons_coverage(&self, id: CelestialBodyId) -> Option<TableCoverage> {
        self.horizons.as_ref()?.coverage(id)
    }

    /// Check if the current simulation time is beyond the ephemeris table coverage
    /// for any planet.
    ///
    /// When true, planet positions are computed using Kepler approximations
    /// rather than high-accuracy table data. This is useful for displaying
    /// an "Estimated" indicator in the UI.
    ///
    /// # Arguments
    /// * `time` - Time in seconds since J2000 epoch
    ///
    /// # Returns
    /// `true` if time is beyond the table coverage end for planets (year ~2200),
    /// `false` if within table coverage or if no tables are loaded.
    pub fn is_beyond_table_coverage(&self, time: f64) -> bool {
        let Some(h) = &self.horizons else {
            // No tables loaded - pure Kepler always, but don't flag as "beyond"
            return false;
        };

        // Check Earth's coverage as representative of planet tables
        // (all planets have the same coverage range)
        if let Some(cov) = h.coverage(CelestialBodyId::Earth) {
            return time > cov.end;
        }

        false
    }

    fn get_kepler_position_by_id(&self, id: CelestialBodyId, time: f64) -> Option<DVec2> {
        let data = self.body_data.get(&id)?;

        match &data.orbit {
            None => Some(DVec2::ZERO), // Sun at origin
            Some(orbit) => {
                let local_pos = orbit.get_local_position(time);

                // Legacy hierarchical orbits (moons): parent heliocentric + local orbit
                match id.parent() {
                    None => Some(local_pos), // Heliocentric orbit
                    Some(parent_id) => {
                        let parent_pos = self.get_position_by_id(parent_id, time)?;
                        Some(parent_pos + local_pos)
                    }
                }
            }
        }
    }

    fn get_kepler_velocity_by_id(&self, id: CelestialBodyId, time: f64) -> Option<DVec2> {
        let data = self.body_data.get(&id)?;

        match &data.orbit {
            None => Some(DVec2::ZERO), // Sun stationary
            Some(orbit) => {
                let local_vel = orbit.get_local_velocity(time);

                // Legacy hierarchical orbits (moons): parent heliocentric + local orbit
                match id.parent() {
                    None => Some(local_vel), // Heliocentric
                    Some(parent_id) => {
                        let parent_vel = self.get_velocity_by_id(parent_id, time)?;
                        Some(parent_vel + local_vel)
                    }
                }
            }
        }
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::types::{AU_TO_METERS, SECONDS_PER_DAY};

    #[test]
    fn test_ephemeris_creation() {
        let eph = Ephemeris::new();
        assert!(eph.body_data.contains_key(&CelestialBodyId::Sun));
        assert!(eph.body_data.contains_key(&CelestialBodyId::Earth));
        assert!(eph.body_data.contains_key(&CelestialBodyId::Moon));
    }

    #[test]
    fn test_sun_position() {
        let eph = Ephemeris::new();
        let sun_pos = eph.get_position_by_id(CelestialBodyId::Sun, 0.0);
        assert_eq!(sun_pos, Some(DVec2::ZERO));
    }

    #[test]
    fn test_earth_position_at_epoch() {
        let eph = Ephemeris::new();
        let earth_pos = eph.get_position_by_id(CelestialBodyId::Earth, 0.0).unwrap();

        // Earth should be roughly 1 AU from Sun at J2000
        let distance_au = earth_pos.length() / AU_TO_METERS;
        assert!(
            (distance_au - 1.0).abs() < 0.02,
            "Earth should be ~1 AU from Sun, got {} AU",
            distance_au
        );
    }

    #[test]
    fn test_moon_position_relative_to_earth() {
        let eph = Ephemeris::new();

        let earth_pos = eph.get_position_by_id(CelestialBodyId::Earth, 0.0).unwrap();
        let moon_pos = eph.get_position_by_id(CelestialBodyId::Moon, 0.0).unwrap();

        // Moon should be ~384,400 km from Earth
        let distance_km = (moon_pos - earth_pos).length() / 1000.0;
        assert!(
            (distance_km - 384400.0).abs() < 50000.0,
            "Moon should be ~384,400 km from Earth, got {} km",
            distance_km
        );
    }

    #[test]
    fn test_gravity_sources() {
        let eph = Ephemeris::new();
        let sources = eph.get_gravity_sources(0.0);

        // Should have Sun + 8 planets = 9 sources (moons are decorative only)
        assert_eq!(sources.len(), 9);

        // Sun should have largest GM
        let sun_gm = sources[0].1;
        for (_, gm) in &sources[1..] {
            assert!(sun_gm > *gm);
        }
    }

    #[test]
    fn test_collision_detection() {
        let eph = Ephemeris::new();

        // Position at Sun's center should collide
        let collision = eph.check_collision(DVec2::ZERO, 0.0);
        assert_eq!(collision, Some(CelestialBodyId::Sun));

        // Position far from everything should not collide
        let far_pos = DVec2::new(100.0 * AU_TO_METERS, 0.0);
        let no_collision = eph.check_collision(far_pos, 0.0);
        assert!(no_collision.is_none());
    }

    #[test]
    fn test_entity_registration() {
        let mut eph = Ephemeris::new();

        // Create fake entities (in real usage these come from Bevy)
        let fake_entity = Entity::from_bits(42);

        eph.register(fake_entity, CelestialBodyId::Earth);

        assert_eq!(eph.get_id(fake_entity), Some(CelestialBodyId::Earth));
        assert_eq!(eph.get_entity(CelestialBodyId::Earth), Some(fake_entity));
    }

    #[test]
    fn test_planetary_motion_over_time() {
        let eph = Ephemeris::new();

        // Earth position at J2000
        let earth_pos_0 = eph.get_position_by_id(CelestialBodyId::Earth, 0.0).unwrap();

        // Earth position after ~6 months (half orbit)
        let half_year_seconds = 182.625 * SECONDS_PER_DAY;
        let earth_pos_half = eph
            .get_position_by_id(CelestialBodyId::Earth, half_year_seconds)
            .unwrap();

        // Positions should be roughly opposite
        let dot = earth_pos_0.normalize().dot(earth_pos_half.normalize());
        assert!(
            dot < -0.8,
            "Earth after 6 months should be on opposite side of orbit, dot product = {}",
            dot
        );
    }

    #[test]
    fn test_continuity_offsets_do_not_introduce_jumps_when_tables_expire() {
        // This test documents the expected behavior at table boundary.
        //
        // When Horizons table coverage ends, we switch to pure Kepler orbits.
        // This produces a discontinuity (jump) at the boundary equal to the
        // accumulated Horizons-Kepler drift over the table duration (~200 years).
        //
        // We accept this trade-off because:
        // 1. The jump is typically < 0.1 AU for inner planets
        // 2. The alternative (offset extrapolation) produces MUCH larger errors
        //    for outer planets (e.g., Jupiter at 3 AU instead of 5 AU)
        // 3. For a visualization app, correct orbital shapes matter more than
        //    momentary boundary discontinuities
        let eph = Ephemeris::new();

        // If no Horizons tables are loaded (common in CI), this test is a no-op.
        let Some(h) = eph.horizons.as_ref() else {
            return;
        };

        let id = CelestialBodyId::Earth;
        let Some(cov) = h.coverage(id) else {
            return;
        };

        let dt = 1.0; // 1 second
        let t0 = cov.end;
        let t1 = cov.end + dt;

        let p0 = eph.get_position_by_id(id, t0).unwrap();
        let p1 = eph.get_position_by_id(id, t1).unwrap();

        // Expect a discontinuity (Horizons-Kepler offset) at the boundary.
        // For Earth after 200 years, this is typically < 0.05 AU.
        let jump = (p1 - p0).length() / AU_TO_METERS;

        // Verify the jump is bounded - not absurdly large
        assert!(
            jump < 0.1,
            "Boundary jump should be < 0.1 AU for Earth, got {} AU",
            jump
        );

        // After the boundary, positions should follow pure Kepler
        // (no further offset-induced distortions)
        let t2 = cov.end + 365.25 * SECONDS_PER_DAY; // 1 year past boundary
        let p2 = eph.get_position_by_id(id, t2).unwrap();
        let r2 = p2.length() / AU_TO_METERS;

        // Earth should still be ~1 AU from Sun (Kepler gives stable orbits)
        assert!(
            r2 > 0.95 && r2 < 1.05,
            "Earth should remain ~1 AU from Sun after boundary, got {} AU",
            r2
        );
    }

    #[test]
    fn test_continuity_offsets_work_for_moons_if_tables_present() {
        // Note: For moons, we deliberately skip the offset-based continuity approach
        // because the Horizons table data for moons can diverge from the parent planet
        // position over time. Instead, we use pure Kepler (parent + local orbit) outside
        // table coverage, which may create a small discontinuity at the boundary but
        // ensures moons are always correctly positioned near their parent planet.
        //
        // This test now just verifies that moon positions are reasonable on both sides
        // of the table boundary.
        let eph = Ephemeris::new();

        let Some(h) = eph.horizons.as_ref() else {
            return;
        };

        let id = CelestialBodyId::Moon;
        let Some(cov) = h.coverage(id) else {
            return;
        };

        let t0 = cov.end;
        let t1 = cov.end + 1.0;

        let p0 = eph.get_position_by_id(id, t0).unwrap();
        let p1 = eph.get_position_by_id(id, t1).unwrap();

        // Both positions should be at roughly Earth's orbital distance (1 AU ± 0.01 AU for Moon)
        let au = 1.496e11;
        let d0 = p0.length() / au;
        let d1 = p1.length() / au;

        assert!(
            (0.98..=1.02).contains(&d0),
            "Moon at table end should be near 1 AU, got {} AU",
            d0
        );
        assert!(
            (0.98..=1.02).contains(&d1),
            "Moon just past table end should be near 1 AU, got {} AU",
            d1
        );

        // And the Moon should be close to Earth on both sides
        let earth_p0 = eph.get_position_by_id(CelestialBodyId::Earth, t0).unwrap();
        let earth_p1 = eph.get_position_by_id(CelestialBodyId::Earth, t1).unwrap();

        let moon_earth_dist_0 = (p0 - earth_p0).length() / au;
        let moon_earth_dist_1 = (p1 - earth_p1).length() / au;

        // Moon should be within 0.02 AU of Earth (actual distance ~0.0026 AU)
        // Note: The Horizons table data can drift near the end of coverage
        assert!(
            moon_earth_dist_0 < 0.02,
            "Moon at table end should be close to Earth, got {} AU",
            moon_earth_dist_0
        );
        assert!(
            moon_earth_dist_1 < 0.02,
            "Moon past table end should be close to Earth, got {} AU",
            moon_earth_dist_1
        );
    }

    #[test]
    fn test_long_extrapolation_orbit_stability() {
        // Verify that Earth's orbit remains elliptical and Sun-centered at year 2844
        // (644 years past table end). With the constant offset approach, orbits would
        // be offset from the Sun. With pure Kepler fallback, orbits remain centered.
        let eph = Ephemeris::new();

        // Time at year 2844 (844 years after J2000)
        let time_2844 = 844.0 * 365.25 * SECONDS_PER_DAY;

        // Sample Earth position over one orbit (12 points)
        let period = 365.25 * SECONDS_PER_DAY;
        let mut positions = vec![];
        for i in 0..12 {
            let t = time_2844 + (i as f64 / 12.0) * period;
            if let Some(pos) = eph.get_position_by_id(CelestialBodyId::Earth, t) {
                positions.push(pos);
            }
        }

        assert_eq!(positions.len(), 12, "Should get 12 position samples");

        // Compute orbit center (should be near origin for Sun-centered orbit)
        let center = positions.iter().fold(DVec2::ZERO, |a, &b| a + b) / 12.0;
        let center_offset_au = center.length() / AU_TO_METERS;

        // Center should be within 0.05 AU of origin (Sun)
        // Pure Kepler orbits use mean elements that differ slightly from actual positions,
        // but this is MUCH better than the old constant-offset approach which could
        // produce offsets of many AU over centuries due to accumulated phase errors.
        assert!(
            center_offset_au < 0.05,
            "Orbit center should be near Sun at year 2844, got offset {} AU",
            center_offset_au
        );

        // Verify orbit radii are reasonable (Earth: perihelion ~0.98 AU, aphelion ~1.02 AU)
        for pos in &positions {
            let r_au = pos.length() / AU_TO_METERS;
            assert!(
                r_au > 0.95 && r_au < 1.05,
                "Earth should be ~1 AU from Sun at year 2844, got {} AU",
                r_au
            );
        }
    }

    #[test]
    fn test_pure_kepler_is_stable_at_large_times() {
        // Pure Kepler should produce stable ellipses at any time
        let eph = Ephemeris::new();

        // Test at 1000 years past J2000
        let time_far_future = 1000.0 * 365.25 * SECONDS_PER_DAY;

        // Earth
        let earth_pos = eph
            .get_position_by_id(CelestialBodyId::Earth, time_far_future)
            .expect("Should get Earth position");
        let earth_r_au = earth_pos.length() / AU_TO_METERS;
        assert!(
            earth_r_au > 0.95 && earth_r_au < 1.05,
            "Earth should be ~1 AU from Sun at far future, got {} AU",
            earth_r_au
        );

        // Jupiter
        let jupiter_pos = eph
            .get_position_by_id(CelestialBodyId::Jupiter, time_far_future)
            .expect("Should get Jupiter position");
        let jupiter_r_au = jupiter_pos.length() / AU_TO_METERS;
        assert!(
            jupiter_r_au > 4.9 && jupiter_r_au < 5.5,
            "Jupiter should be ~5.2 AU from Sun at far future, got {} AU",
            jupiter_r_au
        );

        // Neptune (outermost)
        let neptune_pos = eph
            .get_position_by_id(CelestialBodyId::Neptune, time_far_future)
            .expect("Should get Neptune position");
        let neptune_r_au = neptune_pos.length() / AU_TO_METERS;
        assert!(
            neptune_r_au > 29.0 && neptune_r_au < 31.0,
            "Neptune should be ~30 AU from Sun at far future, got {} AU",
            neptune_r_au
        );
    }

    #[test]
    fn test_is_beyond_table_coverage() {
        let eph = Ephemeris::new();

        // J2000 should be within coverage (if tables are loaded)
        let within = eph.is_beyond_table_coverage(0.0);

        // Year 2844 should be beyond coverage
        let time_2844 = 844.0 * 365.25 * SECONDS_PER_DAY;
        let beyond = eph.is_beyond_table_coverage(time_2844);

        // If no tables loaded, both should be false
        if eph.horizons.is_some() {
            assert!(!within, "J2000 should be within table coverage");
            assert!(beyond, "Year 2844 should be beyond table coverage");
        } else {
            // No tables - always returns false
            assert!(!within);
            assert!(!beyond);
        }
    }

    #[test]
    fn test_drifting_offset_does_not_distort_orbits() {
        // Regression test for drifting offset bug:
        // At year 2222 (22 years past table end in 2200), the formula:
        //   drifted_dp = offset.dp + offset.dv * dt
        // produces offsets of ~23 AU because dt is huge (22 years in seconds).
        //
        // This test verifies that Mars stays closer to Sun than Jupiter
        // when extrapolating 22 years past table end (within 50-year limit).
        let eph = Ephemeris::new();

        // Skip if no tables loaded - this bug only manifests with tables
        let Some(h) = &eph.horizons else { return };
        let Some(cov) = h.coverage(CelestialBodyId::Earth) else {
            return;
        };

        // 22 years past table end - within the 50-year drifting offset window
        let time_22y_past_end = cov.end + 22.0 * 365.25 * SECONDS_PER_DAY;

        // Get positions for Mars and Jupiter
        let mars_pos = eph
            .get_position_by_id(CelestialBodyId::Mars, time_22y_past_end)
            .expect("Mars position should be available");
        let jupiter_pos = eph
            .get_position_by_id(CelestialBodyId::Jupiter, time_22y_past_end)
            .expect("Jupiter position should be available");

        let mars_r = mars_pos.length() / AU_TO_METERS;
        let jupiter_r = jupiter_pos.length() / AU_TO_METERS;

        // Mars (~1.5 AU) must be closer to Sun than Jupiter (~5.2 AU)
        assert!(
            mars_r < jupiter_r,
            "Mars ({:.2} AU) should be closer to Sun than Jupiter ({:.2} AU)",
            mars_r,
            jupiter_r
        );

        // Verify reasonable orbital radii
        // Mars: 1.38 AU perihelion to 1.67 AU aphelion, allow some margin
        assert!(
            mars_r > 1.0 && mars_r < 2.0,
            "Mars should be ~1.5 AU from Sun, got {:.2} AU",
            mars_r
        );

        // Jupiter: 4.95 AU perihelion to 5.46 AU aphelion, allow some margin
        assert!(
            jupiter_r > 4.5 && jupiter_r < 6.0,
            "Jupiter should be ~5.2 AU from Sun, got {:.2} AU",
            jupiter_r
        );
    }
}

#[cfg(test)]
mod position_tests {
    use super::*;

    const AU: f64 = 1.496e11;

    /// Tests that moons are correctly positioned near their parent planets.
    /// This tests both within-table-coverage (year 1) and outside-table-coverage (year 26).
    fn test_moons_near_parent(eph: &Ephemeris, time: f64, label: &str) {
        let jupiter_pos = eph
            .get_position_by_id(CelestialBodyId::Jupiter, time)
            .expect("Jupiter position should be available");
        let jupiter_dist_au = jupiter_pos.length() / AU;

        assert!(
            jupiter_dist_au > 4.5 && jupiter_dist_au < 6.5,
            "{}: Jupiter should be 4.5-6.5 AU from Sun, got {:.4} AU",
            label,
            jupiter_dist_au
        );

        for &moon_id in &[
            CelestialBodyId::Io,
            CelestialBodyId::Europa,
            CelestialBodyId::Ganymede,
            CelestialBodyId::Callisto,
        ] {
            let moon_pos = eph
                .get_position_by_id(moon_id, time)
                .unwrap_or_else(|| panic!("{:?} position should be available", moon_id));
            let dist_from_jupiter = (moon_pos - jupiter_pos).length() / AU;

            assert!(
                dist_from_jupiter < 0.02,
                "{}: {:?} should be < 0.02 AU from Jupiter, got {:.6} AU",
                label,
                moon_id,
                dist_from_jupiter
            );
        }
    }

    #[test]
    fn test_jupiter_moons_within_table_coverage() {
        let eph = Ephemeris::new();
        // 1 year after J2000 - within table coverage
        let time = 365.25 * 86400.0;
        test_moons_near_parent(&eph, time, "year 1");
    }

    #[test]
    fn test_jupiter_moons_outside_table_coverage() {
        let eph = Ephemeris::new();
        // 26 years after J2000 - outside moon table coverage (tables end at ~24 years)
        let time = 26.0 * 365.25 * 86400.0;
        test_moons_near_parent(&eph, time, "year 26");
    }

    #[test]
    fn test_gravity_sources_full_matches_gravity_sources() {
        // Verify that get_gravity_sources_full() returns the same positions and GMs
        // as get_gravity_sources(), just with additional collision radius data.
        let eph = Ephemeris::new();

        // Test at several times within and outside table coverage
        let test_times = [
            0.0,                                // J2000 epoch
            365.25 * 86400.0,                   // 1 year
            10.0 * 365.25 * 86400.0,            // 10 years
            200.0 * 365.25 * 86400.0,           // 200 years (past table coverage)
        ];

        for time in test_times {
            let sources = eph.get_gravity_sources(time);
            let sources_full = eph.get_gravity_sources_full(time);

            for i in 0..GRAVITY_SOURCE_COUNT {
                let (pos, gm) = sources[i];
                let full = &sources_full[i];

                // Positions must match exactly
                assert!(
                    (pos.x - full.pos.x).abs() < 1e-6,
                    "Position X mismatch at time {}: index {}, got {} vs {}",
                    time, i, pos.x, full.pos.x
                );
                assert!(
                    (pos.y - full.pos.y).abs() < 1e-6,
                    "Position Y mismatch at time {}: index {}, got {} vs {}",
                    time, i, pos.y, full.pos.y
                );

                // GMs must match exactly
                assert!(
                    (gm - full.gm).abs() < 1e-6,
                    "GM mismatch at time {}: index {}, got {} vs {}",
                    time, i, gm, full.gm
                );

                // Collision radius must be positive for valid sources
                if gm > 0.0 {
                    assert!(
                        full.collision_radius > 0.0,
                        "Collision radius should be positive for body with GM > 0 at time {}",
                        time
                    );
                }
            }
        }
    }

    #[test]
    fn test_sample_position_matches_sample_pos_component() {
        // Verify that sample_position() returns the same position as sample().pos
        // This ensures the two code paths are consistent.
        let eph = Ephemeris::new();

        // Only test if we have Horizons tables loaded
        if let Some(horizons) = &eph.horizons {
            let test_times = [
                0.0,
                86400.0,              // 1 day
                365.25 * 86400.0,     // 1 year
                10.0 * 365.25 * 86400.0, // 10 years
            ];

            // Test each planet table
            for body_id in CelestialBodyId::PLANETS {
                if let Some(table) = horizons.table(*body_id) {
                    // Check if the times are within table range
                    let start = table.start_time();
                    let end = table.end_time();

                    for &time in &test_times {
                        if time >= start && time <= end {
                            // Get position from sample() (full state)
                            let full_state = table.sample(time);
                            // Get position from sample_position() (position only)
                            let pos_only = table.sample_position(time);

                            match (full_state, pos_only) {
                                (Ok(state), Ok(pos)) => {
                                    // Position components must match
                                    let diff = (state.pos - pos).length();
                                    assert!(
                                        diff < 1e-10,
                                        "sample_position() mismatch for {:?} at time {}: diff = {} m",
                                        body_id, time, diff
                                    );
                                }
                                (Err(e1), Err(e2)) => {
                                    // Both errored - that's fine, they're consistent
                                    panic!(
                                        "Both sample functions failed for {:?}: {:?}, {:?}",
                                        body_id, e1, e2
                                    );
                                }
                                _ => {
                                    panic!(
                                        "Inconsistent results for {:?} at time {}",
                                        body_id, time
                                    );
                                }
                            }
                        }
                    }
                }
            }
        }
    }


    #[test]
    fn test_collision_radii_in_gravity_sources_full() {
        // Verify collision radii are computed correctly for all bodies
        let eph = Ephemeris::new();
        let time = 0.0; // J2000 epoch
        let sources = eph.get_gravity_sources_full(time);

        // Sun should have ~2x radius (small multiplier)
        let sun_data = eph.get_body_data_by_id(CelestialBodyId::Sun).unwrap();
        assert!(
            (sources[0].collision_radius - sun_data.radius * super::SUN_COLLISION_MULT).abs() < 1.0,
            "Sun collision radius should be ~2x physical radius"
        );

        // Earth should have 50x radius (large multiplier for asteroid collision)
        let earth_data = eph.get_body_data_by_id(CelestialBodyId::Earth).unwrap();
        let earth_idx = BODY_ORDER.iter().position(|&id| id == CelestialBodyId::Earth).unwrap();
        assert!(
            (sources[earth_idx].collision_radius - earth_data.radius * COLLISION_MULTIPLIER).abs() < 1.0,
            "Earth collision radius should be ~50x physical radius"
        );
    }

    #[test]
    fn test_position_falls_back_to_kepler_outside_table_range() {
        let eph = Ephemeris::new();

        // Far future time - definitely outside any table range (100 years from J2000)
        let far_future = 100.0 * 365.25 * 86400.0;

        // Should still return a position (from Kepler), not None
        let earth_pos = eph.get_position_by_id(CelestialBodyId::Earth, far_future);
        assert!(earth_pos.is_some(), "Should fall back to Kepler for far future times");

        // And the velocity should also work
        let earth_vel = eph.get_velocity_by_id(CelestialBodyId::Earth, far_future);
        assert!(earth_vel.is_some(), "Velocity should also fall back to Kepler");
    }
}
